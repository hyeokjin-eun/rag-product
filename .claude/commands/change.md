# Change 커맨드

기존 기능을 변경하거나 개선합니다.

## 입력

- $ARGUMENTS: 도메인 이름 (예: documents, search, embeddings, rag)

## 작업 흐름

```
[1. 변경 요구사항 수집]
        ↓
[2. 현재 상태 파악]
        ↓
[3. 코드 재활용 분석] ←── agents/code-analyzer.md
        ↓
[4. 변경 영향 분석]
        ↓
[5. 스펙 문서 수정]
        ↓
[6. 코드 수정]
        ↓
[7. 테스트 수정]
        ↓
[8. 빌드 및 검증]
        ↓
[9. 문서 최신화 확인] ←── 스펙/코드 일치 검증 (필수)
        ↓
[10. /review 실행]
        ↓
[11. 완료]
```

---

## 작업 순서

### 1. 변경 요구사항 수집

사용자에게 다음을 질문하세요:

- 어떤 기능을 변경하나요?
- 현재 동작 vs 원하는 동작은?
- 새로운 필드/API/로직이 추가되나요?
- 기존 필드/API/로직이 삭제되나요?
- 하위 호환성이 필요한가요?

### 2. 현재 상태 파악

스펙 문서와 구현 코드를 확인하세요:

```
.claude/specs/$ARGUMENTS.md   # 현재 스펙

app/domains/$ARGUMENTS/
├── schemas.py                # 현재 스키마
├── service.py                # 현재 비즈니스 로직
└── repository.py             # 현재 데이터 접근

app/api/v1/$ARGUMENTS.py      # 현재 API
```

### 3. 코드 재활용 분석

`.claude/agents/code-analyzer.md` 가이드를 참조하여 변경 시 재활용 가능한 코드 분석:

**분석 대상:**
```
app/domains/*/schemas.py     # 다른 도메인의 재활용 가능한 스키마
app/domains/*/service.py     # 다른 도메인의 재활용 가능한 로직
app/core/                    # 공통 유틸리티, 예외
app/utils/                   # 헬퍼 함수
```

**분석 결과 보고:**
- 변경 시 새로 가져올 수 있는 공통 코드
- 이번 변경으로 공통화할 수 있는 코드 (다른 도메인에서도 사용 가능)

### 4. 변경 영향 분석

변경이 영향을 미치는 범위를 분석하세요:

| 영향 범위 | 확인 내용 |
|-----------|-----------|
| 스펙 문서 | 어떤 섹션이 변경되나? |
| 스키마 | 필드 추가/삭제/타입 변경? |
| 서비스 | 비즈니스 로직 변경? |
| API | 엔드포인트/요청/응답 변경? |
| 테스트 | 어떤 테스트가 수정 필요? |
| 다른 도메인 | 의존하는 도메인 영향? |

**사용자에게 변경 계획을 보여주고 확인받으세요:**

```markdown
## 변경 계획

### 스펙 수정
- 2.1 엔티티: {필드} 추가
- 3.2 API: {엔드포인트} 응답 변경

### 코드 수정
- schemas.py: {변경 내용}
- service.py: {변경 내용}
- api/v1/{domain}.py: {변경 내용}

### 테스트 수정
- test_{domain}.py: {변경 내용}

이대로 진행할까요?
```

### 5. 스펙 문서 수정

`.claude/specs/$ARGUMENTS.md`의 해당 섹션을 수정하세요:

- 데이터 모델 변경 → 2장 수정
- API 변경 → 3장 수정
- 비즈니스 로직 변경 → 4장 수정
- 에러 추가/변경 → 6장 수정
- 테스트 케이스 추가 → 9장 수정

### 6. 코드 수정

스펙 변경에 맞춰 코드를 수정하세요:

| 스펙 섹션 | 수정 파일 |
|-----------|-----------|
| 2. 데이터 모델 | schemas.py |
| 3. API 명세 | api/v1/{domain}.py |
| 4. 비즈니스 로직 | service.py |
| 5. 외부 연동 | repository.py |
| 6. 에러 처리 | exceptions.py, service.py |

### 7. 테스트 수정

변경된 기능에 맞게 테스트를 수정/추가하세요:

| 변경 내용 | 테스트 수정 |
|-----------|-------------|
| 필드 추가 | 생성/수정 테스트에 새 필드 포함 |
| API 변경 | API 테스트 요청/응답 수정 |
| 로직 변경 | 해당 로직 테스트 수정 |
| 에러 추가 | 에러 케이스 테스트 추가 |

### 8. 빌드 및 검증

수정 완료 후 다음을 실행하여 검증:

```bash
# 1. 타입 체크
mypy app/domains/$ARGUMENTS/

# 2. 린트 검사
ruff check app/domains/$ARGUMENTS/
ruff check app/api/v1/$ARGUMENTS.py

# 3. 단위 테스트
pytest tests/unit/domains/test_$ARGUMENTS.py -v

# 4. 통합 테스트
pytest tests/integration/test_$ARGUMENTS_api.py -v

# 5. 영향받는 다른 도메인 테스트 (있는 경우)
pytest tests/ -k "{related_domain}" -v
```

**검증 실패 시:**
- 에러 메시지 확인 후 해당 코드 수정
- 모든 테스트 통과할 때까지 반복

### 9. 문서 최신화 확인 (필수)

스펙 문서와 실제 코드가 일치하는지 최종 확인:

| 확인 항목 | 체크 |
|-----------|------|
| 스펙 2장 데이터 모델 ↔ schemas.py | ✅/❌ |
| 스펙 3장 API 명세 ↔ api/v1/*.py | ✅/❌ |
| 스펙 4장 비즈니스 로직 ↔ service.py | ✅/❌ |
| 스펙 6장 에러 코드 ↔ exceptions.py | ✅/❌ |
| 스펙 9장 테스트 시나리오 ↔ tests/ | ✅/❌ |

**불일치 항목이 있으면:**
- 스펙 문서 또는 코드를 수정하여 일치시키세요
- 변경 이력을 스펙 문서에 기록하세요

### 10. /review 실행

변경 완료 후 `/review $ARGUMENTS` 를 실행하여 검증하세요.

### 11. 완료 보고

```
✅ 기능 변경 완료

## 변경 요약
- {1줄 요약}

## 스펙 변경
- `.claude/specs/$ARGUMENTS.md`
  - {변경된 섹션}: {변경 내용}

## 코드 변경
- {파일}: {변경 내용}

## 테스트 변경
- {테스트 파일}: {변경 내용}

## 하위 호환성
- {호환성 관련 내용}

## 커밋
feat: {변경 설명}
또는
refactor: {변경 설명}
```

---

## 하위 호환성 가이드

기존 API를 사용하는 클라이언트가 있다면:

| 변경 유형 | 호환성 | 대응 |
|-----------|--------|------|
| 필드 추가 (선택) | ✅ 호환 | 기본값 설정 |
| 필드 추가 (필수) | ❌ 비호환 | 마이그레이션 필요 |
| 필드 삭제 | ❌ 비호환 | Deprecated 후 삭제 |
| 필드 타입 변경 | ❌ 비호환 | 새 필드로 추가 |
| 엔드포인트 삭제 | ❌ 비호환 | Deprecated 후 삭제 |

비호환 변경이 필요하면 사용자에게 알리고 마이그레이션 방안을 제시하세요.
