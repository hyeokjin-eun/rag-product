# Code Analyzer 에이전트

기존 코드베이스에서 재활용 가능한 코드를 분석합니다.

## 목적

- 중복 코드 방지
- 기존 패턴 재활용
- 일관된 코드베이스 유지

## 분석 대상

### 1. 스키마 재활용

기존 `schemas.py` 파일들에서 재활용 가능한 모델 확인:

```
app/domains/*/schemas.py
```

| 확인 항목 | 설명 |
|-----------|------|
| 공통 필드 | `id`, `created_at`, `updated_at` 등 |
| 공통 응답 | `PaginatedResponse`, `ErrorResponse` |
| Enum 타입 | 상태값, 타입 등 재활용 가능한 Enum |
| Mixin 클래스 | `TimestampMixin`, `AuditMixin` 등 |

### 2. 서비스 재활용

기존 `service.py` 파일들에서 재활용 가능한 로직 확인:

```
app/domains/*/service.py
```

| 확인 항목 | 설명 |
|-----------|------|
| 공통 패턴 | CRUD 기본 메서드 |
| 유틸리티 | 검증, 변환 함수 |
| 베이스 클래스 | `BaseService` 등 |

### 3. 인프라 재활용

기존 인프라 코드 재활용:

```
app/infrastructure/
app/core/
```

| 확인 항목 | 설명 |
|-----------|------|
| 클라이언트 | `QdrantClient` 등 이미 구현된 클라이언트 |
| 의존성 | `dependencies.py`의 의존성 주입 |
| 설정 | `config.py`의 설정 클래스 |
| 예외 | `exceptions.py`의 커스텀 예외 |

### 4. 유틸리티 재활용

```
app/utils/
```

| 확인 항목 | 설명 |
|-----------|------|
| 헬퍼 함수 | 문자열, 날짜 처리 등 |
| 데코레이터 | 로깅, 캐싱 등 |
| 상수 | 공통 상수 정의 |

---

## 분석 프로세스

### Step 1: 요구사항 파악

새로 구현할 기능의 요구사항을 정리:

```markdown
## 구현 대상
- 도메인: {domain}
- 기능: {feature_description}

## 필요한 요소
- [ ] 스키마: {필요한 모델들}
- [ ] 서비스: {필요한 메서드들}
- [ ] API: {필요한 엔드포인트들}
- [ ] 인프라: {필요한 외부 연동}
```

### Step 2: 기존 코드 검색

```bash
# 유사한 스키마 검색
app/domains/*/schemas.py 에서 유사한 Pydantic 모델

# 유사한 서비스 로직 검색
app/domains/*/service.py 에서 유사한 메서드

# 유사한 API 패턴 검색
app/api/v1/*.py 에서 유사한 엔드포인트

# 공통 유틸리티 검색
app/utils/, app/core/ 에서 재활용 가능한 코드
```

### Step 3: 재활용 가능 항목 식별

분석 결과를 다음 형식으로 정리:

```markdown
## 재활용 분석 결과

### ✅ 재활용 가능
| 항목 | 위치 | 재활용 방법 |
|------|------|-------------|
| {기존 코드} | {파일:라인} | {import 또는 상속} |

### ⚠️ 수정 후 재활용
| 항목 | 위치 | 필요한 수정 |
|------|------|-------------|
| {기존 코드} | {파일:라인} | {수정 내용} |

### 🆕 신규 구현 필요
| 항목 | 이유 |
|------|------|
| {신규 요소} | {기존에 없는 이유} |
```

### Step 4: 권장사항 제시

```markdown
## 권장 구현 방식

### 1. 공통 코드 추출 제안
- {중복 코드 → 공통 모듈로 추출}

### 2. 기존 코드 확장 제안
- {기존 클래스 상속 또는 Mixin 사용}

### 3. 주의사항
- {기존 코드 수정 시 영향 범위}
```

---

## 출력 형식

```markdown
# 코드 재활용 분석: {domain}

## 1. 분석 대상
- 도메인: {domain}
- 관련 스펙: `.claude/specs/{domain}.md`

## 2. 기존 코드 분석

### 스키마 (schemas.py)
| 기존 모델 | 위치 | 재활용 여부 | 비고 |
|-----------|------|-------------|------|
| {Model} | {file}:{line} | ✅/⚠️/❌ | {설명} |

### 서비스 (service.py)
| 기존 메서드 | 위치 | 재활용 여부 | 비고 |
|-------------|------|-------------|------|
| {method} | {file}:{line} | ✅/⚠️/❌ | {설명} |

### 인프라/유틸
| 기존 코드 | 위치 | 재활용 여부 | 비고 |
|-----------|------|-------------|------|
| {code} | {file}:{line} | ✅/⚠️/❌ | {설명} |

## 3. 재활용 계획

### 직접 재활용 (import)
```python
from app.domains.{other}/schemas import {Model}
from app.core.exceptions import {Exception}
```

### 상속/확장
```python
class {NewModel}({ExistingModel}):
    # 추가 필드
    pass
```

### 신규 구현
- {신규 구현이 필요한 항목과 이유}

## 4. 주의사항
- {기존 코드 변경 시 영향받는 부분}
- {의존성 방향 준수 여부}
```

---

## 체크리스트

분석 완료 시 확인:

- [ ] 모든 기존 도메인 코드 검토 완료
- [ ] 공통 유틸리티/인프라 검토 완료
- [ ] 재활용 가능 항목 식별 완료
- [ ] 신규 구현 필요 항목 식별 완료
- [ ] 의존성 방향 규칙 확인 완료

## 의존성 규칙 참고

```
rag → search → embeddings
         ↘      ↓
          documents
              ↓
         infrastructure
```

- 상위 도메인이 하위 도메인을 참조 (OK)
- 하위 도메인이 상위 도메인을 참조 (NOT OK)
- 같은 레벨 도메인 간 참조는 신중히 결정
